# Детальный план задач по разработке бота

Этот документ содержит подробное описание задач, необходимых для завершения проекта, с оценкой сложности и потенциальными рисками.

---

### **Этап 1: Настройка и подготовка проекта**

#### **Задача 1.1: Проектирование моделей данных**
-   **Описание:** Определить и описать модели `User` и `GreetingOrder` в файле `prisma/schema.prisma`. Модели должны включать все необходимые поля: ID пользователя, ID чата, имя ребенка, статус заказа (например, `pending`, `processing`, `completed`, `failed`) и путь к сгенерированному видео.
-   **Сложность:** Легкая.
-   **Подводные камни:** Неправильный выбор типов данных; отсутствие необходимых индексов для полей, по которым будет идти частый поиск (например, `userId`, `status`), что может замедлить запросы при росте базы данных.

---

### **Этап 2: Взаимодействие с пользователем (Bot Flow)**

#### **Задача 2.1: Реализация команды `/start`**
-   **Описание:** Создать новый "feature" в `src/bot/features/greeting.ts`. Этот модуль будет обрабатывать команду `/start` и запускать пошаговый диалог с пользователем для сбора информации.
-   **Сложность:** Легкая.
-   **Подводные камни:** Возможный конфликт с другими глобальными обработчиками команды `/start`. Необходимо продумать поведение, если пользователь перезапускает бота в середине другого процесса.

#### **Задача 2.2: Создание пошагового диалога**
-   **Описание:** Используя плагин `grammy/conversations`, реализовать сценарий сбора данных: запрос имени ребенка и финальное подтверждение данных перед постановкой в очередь.
-   **Сложность:** Стандартная.
-   **Подводные камни:** Неправильная обработка выхода из диалога (если пользователь пишет "отмена" или просто другую команду). Отсутствие валидации вводимых данных (например, слишком длинное имя или использование цифр).

#### **Задача 2.3: Сохранение данных и постановка задачи в очередь**
-   **Описание:** После того как пользователь подтвердит все введенные данные, они должны быть сохранены в базу данных через Prisma, а затем создана новая задача в очереди BullMQ для дальнейшей обработки.
-   **Сложность:** Стандартная.
-   **Подводные камни:** Гонка состояний: ошибка может произойти после сохранения в БД, но до постановки в очередь. Нужно обеспечить атомарность операции или предусмотреть механизм для обработки таких "зависших" заказов.

---

### **Этап 3: Реализация логики очереди (Worker)**

#### **Задача 3.1: Реализация фонового обработчика (Worker)**
-   **Описание:** Создать основной цикл воркера в `src/worker.ts`. Он должен подключаться к Redis, забирать задачи из очереди `greeting`, обрабатывать их и управлять их жизненным циклом (завершение, ошибка). Воркер должен быть независимым, отказоустойчивым процессом.
-   **Сложность:** Комплексная.
-   **Подводные камни:** Неправильная обработка "зависших" (stalled) задач в BullMQ. Высокое потребление памяти при обработке "тяжелых" задач. Отсутствие механизма graceful shutdown, что может приводить к потере данных при перезапуске воркера.

---

### **Этап 4: Генерация видео**

#### **Задача 4.1: Генерация аудио-обращения (TTS)**
-   **Описание:** Создать сервис, который будет взаимодействовать с внешним API для синтеза речи. Сервис должен принимать текст (имя ребенка), отправлять его в API, получать аудиофайл и сохранять его. Необходимо реализовать логику для правильного обращения ("Дорогой ИМЯ", "Дорогая ИМЯ").
-   **Сложность:** Комплексная.
-   **Подводные камни:** API TTS-сервиса может быть нестабильным или иметь строгие лимиты на запросы. Логика определения пола по имени может работать некорректно для редких имен. Необходимо безопасно хранить API-ключи и обрабатывать ошибки сети.

#### **Задача 4.2: Обработка и монтаж видео (`ffmpeg`)**
-   **Описание:** Реализовать сервис, который будет использовать `ffmpeg` для наложения сгенерированной аудиодорожки на исходное видеопоздравление. Это включает в себя вызов `ffmpeg` как дочернего процесса из Node.js.
-   **Сложность:** Комплексная.
-   **Подводные камни:** `ffmpeg` должен быть установлен в окружении (в Docker-контейнере). Команды `ffmpeg` могут быть сложными, а их отладка — нетривиальной. Обработка видео — ресурсоемкая операция; нужно контролировать дочерние процессы, чтобы избежать "падения" воркера.

---

### **Этап 5: Интеграция и отправка видео**

#### **Задача 5.1: Обновление статуса и отправка видео**
-   **Описание:** После успешного монтажа видео воркер должен обновить статус заказа в БД на `completed` и отправить видеофайл пользователю в чат с помощью отдельного экземпляра бота.
-   **Сложность:** Стандартная.
-   **Подводные камни:** API Telegram имеет ограничение на размер загружаемого файла (50 МБ для ботов). Пользователь может заблокировать бота до момента отправки видео, что приведет к ошибке, которую нужно корректно обработать.

---

### **Этап 6: Тестирование и отладка**

#### **Задача 6.1: Модульное тестирование**
-   **Описание:** Написать unit-тесты для ключевых сервисов, используя `vitest`. Особое внимание уделить бизнес-логике: валидации, работе с очередью, логике генерации.
-   **Сложность:** Стандартная.
-   **Подводные камни:** Сложность в "мокировании" (mocking) зависимостей, таких как Prisma Client, BullMQ и внешние API. Тесты могут не покрывать все пограничные случаи.

#### **Задача 6.2: Интеграционное тестирование**
-   **Описание:** Провести ручное или полуавтоматическое тестирование всего конвейера: от команды `/start` до получения финального видео.
-   **Сложность:** Комплексная.
-   **Подводные камни:** Сложность в воспроизведении ошибок, зависимость от внешних факторов (работа API Telegram, TTS). Требует много времени для полной проверки всего функционала.

---

### **Этап 7: Деплой**

#### **Задача 7.1: Докеризация приложения**
-   **Описание:** Создать `Dockerfile`, который будет корректно собирать TypeScript-проект, устанавливать `ffmpeg` и другие системные зависимости. Обновить `docker-compose.yml` для запуска двух сервисов: `bot` (веб-сервер) и `worker` (фоновый обработчик).
-   **Сложность:** Стандартная.
-   **Подводные камни:** Большой размер итогового Docker-образа. Неправильная настройка сети между контейнерами или прав доступа к файлам внутри контейнера.
